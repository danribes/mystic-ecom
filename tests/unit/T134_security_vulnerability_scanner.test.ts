/**
 * T134: Security Vulnerability Scanner Tests
 *
 * Comprehensive test suite for security vulnerability scanning functionality
 *
 * Tests:
 * - npm audit report parsing
 * - Vulnerability analysis and categorization
 * - Threshold checking
 * - Report generation (JSON and Markdown)
 * - Recommendation generation
 * - Scanner configuration
 * - Error handling
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { promisify } from 'util';
import { exec } from 'child_process';
import {
  VulnerabilityScanner,
  runSecurityScan,
  validateAuditReport,
  type NpmAuditReport,
  type SecurityScanResult,
  type ScannerConfig,
} from '../../src/lib/security/vulnerabilityScanner';

// Mock exec for testing
vi.mock('child_process', () => ({
  exec: vi.fn(),
}));

vi.mock('util', () => ({
  promisify: vi.fn((fn) => fn),
}));

// Sample npm audit report with vulnerabilities
const mockAuditReportWithVulns: NpmAuditReport = {
  auditReportVersion: 2,
  vulnerabilities: {
    playwright: {
      name: 'playwright',
      severity: 'high',
      isDirect: false,
      range: '<1.55.1',
      via: [
        {
          source: 1109208,
          name: 'playwright',
          dependency: 'playwright',
          title: 'Playwright downloads and installs browsers without verifying SSL certificate',
          url: 'https://github.com/advisories/GHSA-7mvr-c777-76hp',
          severity: 'high',
          cwe: ['CWE-347'],
          cvss: {
            score: 7.5,
            vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
          },
          range: '<1.55.1',
        },
      ],
      effects: ['@playwright/test', 'artillery-engine-playwright'],
      fixAvailable: {
        name: 'artillery',
        version: '1.7.9',
        isSemVerMajor: true,
      },
      nodes: ['node_modules/artillery-engine-playwright/node_modules/playwright'],
    },
    'test-package': {
      name: 'test-package',
      severity: 'critical',
      isDirect: true,
      range: '<=1.0.0',
      via: ['critical-vuln'],
      effects: [],
      fixAvailable: {
        name: 'test-package',
        version: '2.0.0',
        isSemVerMajor: false,
      },
      nodes: ['node_modules/test-package'],
    },
  },
  metadata: {
    vulnerabilities: {
      info: 0,
      low: 0,
      moderate: 0,
      high: 1,
      critical: 1,
      total: 2,
    },
    dependencies: {
      prod: 1153,
      dev: 624,
      optional: 165,
      peer: 38,
      peerOptional: 0,
      total: 1947,
    },
  },
};

// Sample clean audit report (no vulnerabilities)
const mockAuditReportClean: NpmAuditReport = {
  auditReportVersion: 2,
  vulnerabilities: {},
  metadata: {
    vulnerabilities: {
      info: 0,
      low: 0,
      moderate: 0,
      high: 0,
      critical: 0,
      total: 0,
    },
    dependencies: {
      prod: 1153,
      dev: 624,
      optional: 165,
      peer: 38,
      peerOptional: 0,
      total: 1947,
    },
  },
};

describe('T134: Security Vulnerability Scanner', () => {
  describe('VulnerabilityScanner Class', () => {
    describe('Constructor and Configuration', () => {
      it('should create scanner with default config', () => {
        const scanner = new VulnerabilityScanner();
        expect(scanner).toBeDefined();
      });

      it('should create scanner with custom config', () => {
        const config: ScannerConfig = {
          failOnSeverity: ['critical'],
          maxVulnerabilities: {
            critical: 0,
            high: 5,
          },
          outputDir: './custom-reports',
          saveReport: false,
        };

        const scanner = new VulnerabilityScanner(config);
        expect(scanner).toBeDefined();
      });

      it('should merge custom config with defaults', () => {
        const config: ScannerConfig = {
          failOnSeverity: ['critical'],
        };

        const scanner = new VulnerabilityScanner(config);
        expect(scanner).toBeDefined();
      });
    });

    describe('Audit Report Analysis', () => {
      it('should analyze audit report with vulnerabilities', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        expect(result).toBeDefined();
        expect(result.summary.total).toBe(2);
        expect(result.summary.critical).toBe(1);
        expect(result.summary.high).toBe(1);
        expect(result.vulnerabilities.length).toBe(2);
      });

      it('should analyze clean audit report', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportClean);

        expect(result).toBeDefined();
        expect(result.summary.total).toBe(0);
        expect(result.vulnerabilities.length).toBe(0);
        expect(result.passesThreshold).toBe(true);
      });

      it('should sort vulnerabilities by severity', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        // Critical should come first
        expect(result.vulnerabilities[0].severity).toBe('critical');
        expect(result.vulnerabilities[1].severity).toBe('high');
      });

      it('should identify direct dependencies', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        const directVuln = result.vulnerabilities.find((v) => v.package === 'test-package');
        expect(directVuln?.isDirect).toBe(true);

        const indirectVuln = result.vulnerabilities.find((v) => v.package === 'playwright');
        expect(indirectVuln?.isDirect).toBe(false);
      });

      it('should identify fixable vulnerabilities', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        expect(result.fixable).toBeGreaterThan(0);
        expect(result.requiresManualReview).toBeGreaterThan(0);
      });

      it('should extract vulnerability details', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        const playwrightVuln = result.vulnerabilities.find((v) => v.package === 'playwright');

        expect(playwrightVuln).toBeDefined();
        expect(playwrightVuln?.title).toContain('Playwright');
        expect(playwrightVuln?.cvss).toBe(7.5);
        expect(playwrightVuln?.cwe).toContain('CWE-347');
        expect(playwrightVuln?.url).toBe('https://github.com/advisories/GHSA-7mvr-c777-76hp');
      });

      it('should handle breaking changes flag', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        const breakingVuln = result.vulnerabilities.find((v) => v.package === 'playwright');
        expect(breakingVuln?.requiresBreakingChange).toBe(true);

        const nonBreakingVuln = result.vulnerabilities.find((v) => v.package === 'test-package');
        expect(nonBreakingVuln?.requiresBreakingChange).toBe(false);
      });
    });

    describe('Threshold Checking', () => {
      it('should fail when critical vulnerabilities exceed threshold', () => {
        const config: ScannerConfig = {
          failOnSeverity: ['critical'],
        };

        const scanner = new VulnerabilityScanner(config);
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        expect(result.passesThreshold).toBe(false);
      });

      it('should pass when no critical vulnerabilities', () => {
        const config: ScannerConfig = {
          failOnSeverity: ['critical'],
        };

        const scanner = new VulnerabilityScanner(config);
        const result = scanner.analyzeAuditReport(mockAuditReportClean);

        expect(result.passesThreshold).toBe(true);
      });

      it('should check count-based thresholds', () => {
        const config: ScannerConfig = {
          maxVulnerabilities: {
            critical: 0,
            high: 0,
          },
        };

        const scanner = new VulnerabilityScanner(config);
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        expect(result.passesThreshold).toBe(false);
      });

      it('should pass with permissive thresholds', () => {
        const config: ScannerConfig = {
          maxVulnerabilities: {
            critical: 10,
            high: 10,
          },
        };

        const scanner = new VulnerabilityScanner(config);
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        expect(result.passesThreshold).toBe(true);
      });
    });

    describe('Recommendations Generation', () => {
      it('should generate recommendations for vulnerabilities', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        expect(result.recommendations).toBeDefined();
        expect(result.recommendations.length).toBeGreaterThan(0);
      });

      it('should recommend npm audit fix for fixable vulnerabilities', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        const hasFixRecommendation = result.recommendations.some((rec) =>
          rec.includes('npm audit fix')
        );
        expect(hasFixRecommendation).toBe(true);
      });

      it('should warn about breaking changes', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        const hasBreakingWarning = result.recommendations.some((rec) =>
          rec.includes('breaking changes')
        );
        expect(hasBreakingWarning).toBe(true);
      });

      it('should celebrate when no vulnerabilities found', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportClean);

        const hasSuccessMessage = result.recommendations.some((rec) =>
          rec.includes('No vulnerabilities')
        );
        expect(hasSuccessMessage).toBe(true);
      });

      it('should recommend Snyk when not enabled', () => {
        const scanner = new VulnerabilityScanner({ snykEnabled: false });
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        const hasSnykRecommendation = result.recommendations.some((rec) =>
          rec.includes('Snyk')
        );
        expect(hasSnykRecommendation).toBe(true);
      });
    });

    describe('Markdown Report Generation', () => {
      it('should generate markdown report', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);
        const markdown = scanner.generateMarkdownReport(result);

        expect(markdown).toBeDefined();
        expect(typeof markdown).toBe('string');
        expect(markdown.length).toBeGreaterThan(0);
      });

      it('should include summary table', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);
        const markdown = scanner.generateMarkdownReport(result);

        expect(markdown).toContain('## Summary');
        expect(markdown).toContain('| Severity | Count |');
        expect(markdown).toContain('Critical');
        expect(markdown).toContain('High');
      });

      it('should include recommendations', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);
        const markdown = scanner.generateMarkdownReport(result);

        expect(markdown).toContain('## Recommendations');
      });

      it('should include vulnerability details', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);
        const markdown = scanner.generateMarkdownReport(result);

        expect(markdown).toContain('## Vulnerabilities');
        expect(markdown).toContain('playwright');
        expect(markdown).toContain('test-package');
      });

      it('should include CVSS scores when available', () => {
        const scanner = new VulnerabilityScanner();
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);
        const markdown = scanner.generateMarkdownReport(result);

        expect(markdown).toContain('CVSS');
      });

      it('should show pass/fail status', () => {
        const scanner = new VulnerabilityScanner({
          failOnSeverity: ['critical'],
        });
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);
        const markdown = scanner.generateMarkdownReport(result);

        expect(markdown).toMatch(/FAILED|PASSED/);
      });
    });

    describe('Package Exclusions', () => {
      it('should exclude specified packages', () => {
        const config: ScannerConfig = {
          excludePackages: ['playwright'],
        };

        const scanner = new VulnerabilityScanner(config);
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        const playwrightVuln = result.vulnerabilities.find((v) => v.package === 'playwright');
        expect(playwrightVuln).toBeUndefined();
      });

      it('should not exclude non-matching packages', () => {
        const config: ScannerConfig = {
          excludePackages: ['other-package'],
        };

        const scanner = new VulnerabilityScanner(config);
        const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

        expect(result.vulnerabilities.length).toBe(2);
      });
    });
  });

  describe('Utility Functions', () => {
    describe('validateAuditReport', () => {
      it('should validate correct audit report', () => {
        const isValid = validateAuditReport(mockAuditReportWithVulns);
        expect(isValid).toBe(true);
      });

      it('should validate clean audit report', () => {
        const isValid = validateAuditReport(mockAuditReportClean);
        expect(isValid).toBe(true);
      });

      it('should reject invalid audit report', () => {
        const invalid = { foo: 'bar' };
        const isValid = validateAuditReport(invalid);
        expect(isValid).toBe(false);
      });

      it('should reject null', () => {
        const isValid = validateAuditReport(null);
        expect(isValid).toBe(false);
      });

      it('should reject undefined', () => {
        const isValid = validateAuditReport(undefined);
        expect(isValid).toBe(false);
      });

      it('should reject missing vulnerabilities field', () => {
        const invalid = {
          auditReportVersion: 2,
          metadata: {},
        };
        const isValid = validateAuditReport(invalid);
        expect(isValid).toBe(false);
      });

      it('should reject missing metadata field', () => {
        const invalid = {
          auditReportVersion: 2,
          vulnerabilities: {},
        };
        const isValid = validateAuditReport(invalid);
        expect(isValid).toBe(false);
      });
    });
  });

  describe('Severity Ordering', () => {
    it('should order vulnerabilities by severity', () => {
      const report: NpmAuditReport = {
        ...mockAuditReportClean,
        vulnerabilities: {
          low1: { name: 'low1', severity: 'low', isDirect: true, range: '*', via: [], effects: [], fixAvailable: false, nodes: [] },
          critical1: { name: 'critical1', severity: 'critical', isDirect: true, range: '*', via: [], effects: [], fixAvailable: false, nodes: [] },
          moderate1: { name: 'moderate1', severity: 'moderate', isDirect: true, range: '*', via: [], effects: [], fixAvailable: false, nodes: [] },
          high1: { name: 'high1', severity: 'high', isDirect: true, range: '*', via: [], effects: [], fixAvailable: false, nodes: [] },
        },
        metadata: {
          vulnerabilities: {
            info: 0,
            low: 1,
            moderate: 1,
            high: 1,
            critical: 1,
            total: 4,
          },
          dependencies: mockAuditReportClean.metadata.dependencies,
        },
      };

      const scanner = new VulnerabilityScanner();
      const result = scanner.analyzeAuditReport(report);

      expect(result.vulnerabilities[0].severity).toBe('critical');
      expect(result.vulnerabilities[1].severity).toBe('high');
      expect(result.vulnerabilities[2].severity).toBe('moderate');
      expect(result.vulnerabilities[3].severity).toBe('low');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty vulnerabilities object', () => {
      const scanner = new VulnerabilityScanner();
      const result = scanner.analyzeAuditReport(mockAuditReportClean);

      expect(result.vulnerabilities.length).toBe(0);
      expect(result.summary.total).toBe(0);
    });

    it('should handle vulnerabilities without via details', () => {
      const report: NpmAuditReport = {
        ...mockAuditReportClean,
        vulnerabilities: {
          'simple-vuln': {
            name: 'simple-vuln',
            severity: 'moderate',
            isDirect: true,
            range: '*',
            via: ['string-only'],
            effects: [],
            fixAvailable: false,
            nodes: [],
          },
        },
        metadata: {
          vulnerabilities: {
            info: 0,
            low: 0,
            moderate: 1,
            high: 0,
            critical: 0,
            total: 1,
          },
          dependencies: mockAuditReportClean.metadata.dependencies,
        },
      };

      const scanner = new VulnerabilityScanner();
      const result = scanner.analyzeAuditReport(report);

      expect(result.vulnerabilities.length).toBe(1);
      expect(result.vulnerabilities[0].package).toBe('simple-vuln');
    });

    it('should handle vulnerabilities without nodes', () => {
      const report: NpmAuditReport = {
        ...mockAuditReportClean,
        vulnerabilities: {
          'no-nodes': {
            name: 'no-nodes',
            severity: 'high',
            isDirect: false,
            range: '*',
            via: [],
            effects: [],
            fixAvailable: false,
            nodes: [],
          },
        },
        metadata: {
          vulnerabilities: {
            info: 0,
            low: 0,
            moderate: 0,
            high: 1,
            critical: 0,
            total: 1,
          },
          dependencies: mockAuditReportClean.metadata.dependencies,
        },
      };

      const scanner = new VulnerabilityScanner();
      const result = scanner.analyzeAuditReport(report);

      expect(result.vulnerabilities.length).toBe(1);
      expect(result.vulnerabilities[0].path.length).toBe(0);
    });
  });

  describe('Integration Scenarios', () => {
    it('should handle typical project scan', () => {
      const scanner = new VulnerabilityScanner({
        failOnSeverity: ['critical', 'high'],
        saveReport: false,
      });

      const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

      expect(result).toBeDefined();
      expect(result.summary.total).toBeGreaterThan(0);
      expect(result.passesThreshold).toBe(false); // Has critical and high
    });

    it('should handle CI/CD scan with strict thresholds', () => {
      const scanner = new VulnerabilityScanner({
        failOnSeverity: ['critical'],
        maxVulnerabilities: {
          critical: 0,
          high: 0,
        },
      });

      const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

      expect(result.passesThreshold).toBe(false);
    });

    it('should handle development scan with permissive thresholds', () => {
      const scanner = new VulnerabilityScanner({
        maxVulnerabilities: {
          critical: 5,
          high: 10,
          moderate: 50,
        },
      });

      const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

      expect(result.passesThreshold).toBe(true);
    });
  });

  describe('Report Timestamp', () => {
    it('should include timestamp in results', () => {
      const scanner = new VulnerabilityScanner();
      const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

      expect(result.timestamp).toBeDefined();
      expect(new Date(result.timestamp)).toBeInstanceOf(Date);
    });

    it('should use ISO 8601 format for timestamp', () => {
      const scanner = new VulnerabilityScanner();
      const result = scanner.analyzeAuditReport(mockAuditReportWithVulns);

      const isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
      expect(result.timestamp).toMatch(isoRegex);
    });
  });
});
