---
/**
 * VideoThumbnail Component (T192)
 *
 * Optimized video thumbnail with WebP support and lazy loading.
 *
 * Features:
 * - WebP format with JPEG fallback
 * - Responsive srcset for different screen sizes
 * - Lazy loading with Intersection Observer
 * - Aspect ratio preservation
 * - Play icon overlay
 * - Duration badge
 * - Hover effects
 *
 * @param videoId - Cloudflare Stream video ID (required)
 * @param alt - Alt text for accessibility (required)
 * @param time - Timestamp in seconds for thumbnail (optional, default: middle of video)
 * @param width - Thumbnail width in pixels (optional)
 * @param height - Thumbnail height in pixels (optional)
 * @param showDuration - Show duration badge (default: false)
 * @param duration - Video duration in seconds (required if showDuration)
 * @param showPlayIcon - Show play icon overlay (default: true)
 * @param lazy - Enable lazy loading (default: true)
 * @param className - Additional CSS classes (optional)
 * @param onClick - Click handler (optional)
 */

import { getOptimizedThumbnail, getResponsiveThumbnailSrcset } from '@/lib/videoOptimization';

interface Props {
  videoId: string;
  alt: string;
  time?: number;
  width?: number;
  height?: number;
  showDuration?: boolean;
  duration?: number;
  showPlayIcon?: boolean;
  lazy?: boolean;
  className?: string;
  onClick?: string;
}

const {
  videoId,
  alt,
  time,
  width = 640,
  height,
  showDuration = false,
  duration,
  showPlayIcon = true,
  lazy = true,
  className = '',
  onClick,
} = Astro.props;

// Generate WebP and JPEG URLs
const webpUrl = getOptimizedThumbnail(videoId, {
  format: 'webp',
  width,
  height,
  time,
});

const jpegUrl = getOptimizedThumbnail(videoId, {
  format: 'jpeg',
  width,
  height,
  time,
});

// Generate responsive srcsets
const webpSrcset = getResponsiveThumbnailSrcset(videoId, {
  format: 'webp',
  time,
});

const jpegSrcset = getResponsiveThumbnailSrcset(videoId, {
  format: 'jpeg',
  time,
});

// Format duration as MM:SS or HH:MM:SS
function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

const durationText = showDuration && duration ? formatDuration(duration) : null;
---

<div
  class:list={[
    'video-thumbnail-container relative overflow-hidden rounded-lg bg-gray-900',
    className
  ]}
  data-video-id={videoId}
  onclick={onClick}
>
  <!-- Aspect Ratio Container -->
  <div class="aspect-video relative">
    <!-- Picture element with WebP and JPEG sources -->
    {lazy ? (
      <picture>
        <source
          type="image/webp"
          data-lazy-srcset={webpSrcset}
          sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
        />
        <source
          type="image/jpeg"
          data-lazy-srcset={jpegSrcset}
          sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
        />
        <img
          data-lazy-thumbnail={jpegUrl}
          alt={alt}
          class="video-thumbnail w-full h-full object-cover transition-all duration-300 opacity-0"
          width={width}
          height={height || Math.round(width * 9 / 16)}
          decoding="async"
        />
      </picture>
    ) : (
      <picture>
        <source
          type="image/webp"
          srcset={webpSrcset}
          sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
        />
        <source
          type="image/jpeg"
          srcset={jpegSrcset}
          sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
        />
        <img
          src={jpegUrl}
          alt={alt}
          class="video-thumbnail w-full h-full object-cover"
          width={width}
          height={height || Math.round(width * 9 / 16)}
          loading="eager"
          decoding="async"
        />
      </picture>
    )}

    <!-- Loading Placeholder (shown while lazy loading) -->
    {lazy && (
      <div class="thumbnail-loading absolute inset-0 bg-gradient-to-br from-gray-800 to-gray-900 animate-pulse">
        <div class="absolute inset-0 flex items-center justify-center">
          <svg class="w-12 h-12 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </div>
      </div>
    )}

    <!-- Play Icon Overlay -->
    {showPlayIcon && (
      <div class="play-icon-overlay absolute inset-0 flex items-center justify-center bg-black/30 transition-all duration-300 opacity-0 group-hover:opacity-100 hover:bg-black/40">
        <div class="play-icon bg-white rounded-full p-4 shadow-xl transform transition-transform duration-300 group-hover:scale-110">
          <svg class="w-8 h-8 text-primary" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z" />
          </svg>
        </div>
      </div>
    )}

    <!-- Duration Badge -->
    {durationText && (
      <div class="duration-badge absolute bottom-2 right-2 bg-black/80 text-white text-xs font-semibold px-2 py-1 rounded backdrop-blur-sm">
        {durationText}
      </div>
    )}
  </div>
</div>

<style>
  .video-thumbnail-container {
    cursor: pointer;
  }

  .video-thumbnail-container:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  /* Fade in effect when lazy loaded */
  .video-thumbnail.loaded {
    opacity: 1 !important;
  }

  .video-thumbnail.fade-in {
    animation: fadeIn 0.3s ease-in-out forwards;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  /* Hide loading placeholder when image loads */
  .video-thumbnail.loaded ~ .thumbnail-loading {
    display: none;
  }

  /* Show play icon on hover */
  .video-thumbnail-container:hover .play-icon-overlay {
    opacity: 1;
  }

  /* Error state */
  .video-thumbnail.thumbnail-error {
    background-color: #1f2937;
    object-fit: contain;
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .video-thumbnail,
    .play-icon-overlay,
    .play-icon {
      transition: none !important;
      animation: none !important;
    }

    .video-thumbnail-container:hover {
      transform: none;
    }
  }

  /* High contrast mode */
  @media (prefers-contrast: high) {
    .play-icon-overlay {
      background-color: rgba(0, 0, 0, 0.8);
    }

    .duration-badge {
      border: 1px solid white;
    }
  }

  /* Group hover effect (when container is in a group) */
  :global(.group):hover .video-thumbnail-container {
    transform: translateY(-2px);
  }
</style>

<script>
/**
 * VideoThumbnail Client-Side Logic
 *
 * Handles:
 * - Lazy loading initialization
 * - Fade-in animation on load
 * - Error handling
 */

document.addEventListener('DOMContentLoaded', () => {
  // Handle image load events for fade-in animation
  const thumbnails = document.querySelectorAll('[data-lazy-thumbnail]');

  thumbnails.forEach((img) => {
    img.addEventListener('load', () => {
      img.classList.add('loaded');

      // Also hide loading placeholder
      const container = img.closest('.video-thumbnail-container');
      const loading = container?.querySelector('.thumbnail-loading');
      if (loading) {
        loading.style.display = 'none';
      }
    });

    img.addEventListener('error', () => {
      img.classList.add('thumbnail-error');
      console.error('Failed to load video thumbnail');
    });
  });
});
</script>
