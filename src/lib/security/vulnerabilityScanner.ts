/**
 * T134: Security Vulnerability Scanner
 *
 * Comprehensive security scanning system that:
 * - Runs npm audit to detect vulnerabilities
 * - Analyzes and categorizes security issues
 * - Generates detailed security reports
 * - Tracks vulnerability trends over time
 * - Integrates with Snyk (optional)
 * - Provides actionable remediation advice
 *
 * @module vulnerabilityScanner
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

/**
 * Vulnerability severity levels
 */
export type VulnerabilitySeverity = 'critical' | 'high' | 'moderate' | 'low' | 'info';

/**
 * Vulnerability information from npm audit
 */
export interface Vulnerability {
  name: string;
  severity: VulnerabilitySeverity;
  isDirect: boolean;
  range: string;
  via: string[] | VulnerabilityDetail[];
  effects: string[];
  fixAvailable: boolean | FixInfo;
  nodes: string[];
}

/**
 * Detailed vulnerability information
 */
export interface VulnerabilityDetail {
  source: number;
  name: string;
  dependency: string;
  title: string;
  url: string;
  severity: VulnerabilitySeverity;
  cwe: string[];
  cvss: {
    score: number;
    vectorString: string | null;
  };
  range: string;
}

/**
 * Fix information for vulnerabilities
 */
export interface FixInfo {
  name: string;
  version: string;
  isSemVerMajor: boolean;
}

/**
 * npm audit report structure
 */
export interface NpmAuditReport {
  auditReportVersion: number;
  vulnerabilities: Record<string, Vulnerability>;
  metadata: {
    vulnerabilities: Record<VulnerabilitySeverity | 'total', number>;
    dependencies: {
      prod: number;
      dev: number;
      optional: number;
      peer: number;
      peerOptional: number;
      total: number;
    };
  };
}

/**
 * Security scan result
 */
export interface SecurityScanResult {
  timestamp: string;
  summary: {
    total: number;
    critical: number;
    high: number;
    moderate: number;
    low: number;
    info: number;
  };
  vulnerabilities: VulnerabilityReport[];
  recommendations: string[];
  fixable: number;
  requiresManualReview: number;
  passesThreshold: boolean;
}

/**
 * Formatted vulnerability report
 */
export interface VulnerabilityReport {
  package: string;
  severity: VulnerabilitySeverity;
  title: string;
  description: string;
  cvss?: number;
  cwe?: string[];
  url?: string;
  isDirect: boolean;
  affectedVersions: string;
  fixAvailable: boolean;
  fixVersion?: string;
  requiresBreakingChange: boolean;
  path: string[];
}

/**
 * Security scanner configuration
 */
export interface ScannerConfig {
  // Severity thresholds
  failOnSeverity?: VulnerabilitySeverity[];
  maxVulnerabilities?: {
    critical?: number;
    high?: number;
    moderate?: number;
    low?: number;
  };

  // Output options
  outputDir?: string;
  saveReport?: boolean;

  // Snyk integration
  snykEnabled?: boolean;
  snykToken?: string;

  // Exclusions
  excludePackages?: string[];
  excludeDev?: boolean;
}

/**
 * Main vulnerability scanner class
 */
export class VulnerabilityScanner {
  private config: ScannerConfig;

  constructor(config: ScannerConfig = {}) {
    this.config = {
      failOnSeverity: ['critical', 'high'],
      maxVulnerabilities: {
        critical: 0,
        high: 0,
        moderate: 10,
        low: 20,
      },
      outputDir: './security-reports',
      saveReport: true,
      snykEnabled: false,
      excludePackages: [],
      excludeDev: false,
      ...config,
    };
  }

  /**
   * Run npm audit and analyze results
   */
  async runNpmAudit(): Promise<NpmAuditReport> {
    try {
      const { stdout } = await execAsync('npm audit --json', {
        maxBuffer: 10 * 1024 * 1024, // 10MB buffer
      });

      return JSON.parse(stdout);
    } catch (error: any) {
      // npm audit returns exit code 1 if vulnerabilities are found
      // We still get the JSON output in error.stdout
      if (error.stdout) {
        try {
          return JSON.parse(error.stdout);
        } catch {
          throw new Error('Failed to parse npm audit output');
        }
      }
      throw new Error(`npm audit failed: ${error.message}`);
    }
  }

  /**
   * Run Snyk test (if configured)
   */
  async runSnykTest(): Promise<any> {
    if (!this.config.snykEnabled) {
      return null;
    }

    if (!this.config.snykToken) {
      throw new Error('Snyk token is required when Snyk is enabled');
    }

    try {
      const { stdout } = await execAsync(
        `npx snyk test --json --severity-threshold=low`,
        {
          env: {
            ...process.env,
            SNYK_TOKEN: this.config.snykToken,
          },
          maxBuffer: 10 * 1024 * 1024,
        }
      );

      return JSON.parse(stdout);
    } catch (error: any) {
      // Snyk also returns non-zero exit code when vulnerabilities found
      if (error.stdout) {
        try {
          return JSON.parse(error.stdout);
        } catch {
          return null;
        }
      }
      return null;
    }
  }

  /**
   * Analyze npm audit report and generate formatted results
   */
  analyzeAuditReport(report: NpmAuditReport): SecurityScanResult {
    const vulnerabilities: VulnerabilityReport[] = [];
    const recommendations: string[] = [];
    let fixable = 0;
    let requiresManualReview = 0;

    // Process each vulnerability
    for (const [packageName, vuln] of Object.entries(report.vulnerabilities)) {
      // Skip if excluded
      if (this.config.excludePackages?.includes(packageName)) {
        continue;
      }

      // Extract vulnerability details
      const details = this.extractVulnerabilityDetails(packageName, vuln);

      if (details) {
        vulnerabilities.push(details);

        // Track fixable vulnerabilities
        if (vuln.fixAvailable && typeof vuln.fixAvailable === 'object') {
          if (vuln.fixAvailable.isSemVerMajor) {
            requiresManualReview++;
          } else {
            fixable++;
          }
        }
      }
    }

    // Sort by severity
    const severityOrder: Record<VulnerabilitySeverity, number> = {
      critical: 0,
      high: 1,
      moderate: 2,
      low: 3,
      info: 4,
    };

    vulnerabilities.sort(
      (a, b) => severityOrder[a.severity] - severityOrder[b.severity]
    );

    // Generate recommendations
    recommendations.push(
      ...this.generateRecommendations(report, vulnerabilities)
    );

    // Check if scan passes threshold
    const passesThreshold = this.checkThreshold(report.metadata.vulnerabilities);

    return {
      timestamp: new Date().toISOString(),
      summary: {
        total: report.metadata.vulnerabilities.total,
        critical: report.metadata.vulnerabilities.critical,
        high: report.metadata.vulnerabilities.high,
        moderate: report.metadata.vulnerabilities.moderate,
        low: report.metadata.vulnerabilities.low,
        info: report.metadata.vulnerabilities.info,
      },
      vulnerabilities,
      recommendations,
      fixable,
      requiresManualReview,
      passesThreshold,
    };
  }

  /**
   * Extract detailed information from vulnerability
   */
  private extractVulnerabilityDetails(
    packageName: string,
    vuln: Vulnerability
  ): VulnerabilityReport | null {
    let title = `Vulnerability in ${packageName}`;
    let description = '';
    let cvss: number | undefined;
    let cwe: string[] | undefined;
    let url: string | undefined;

    // Extract details from via field
    if (Array.isArray(vuln.via)) {
      for (const v of vuln.via) {
        if (typeof v === 'object' && 'title' in v) {
          title = v.title;
          description = v.title;
          cvss = v.cvss?.score;
          cwe = v.cwe;
          url = v.url;
          break;
        }
      }
    }

    // Build dependency path
    const path = vuln.nodes.length > 0 ? [vuln.nodes[0]] : [];

    // Extract fix information
    let fixVersion: string | undefined;
    let requiresBreakingChange = false;

    if (vuln.fixAvailable && typeof vuln.fixAvailable === 'object') {
      fixVersion = vuln.fixAvailable.version;
      requiresBreakingChange = vuln.fixAvailable.isSemVerMajor;
    }

    return {
      package: packageName,
      severity: vuln.severity,
      title,
      description,
      cvss,
      cwe,
      url,
      isDirect: vuln.isDirect,
      affectedVersions: vuln.range,
      fixAvailable: !!vuln.fixAvailable,
      fixVersion,
      requiresBreakingChange,
      path,
    };
  }

  /**
   * Generate actionable recommendations
   */
  private generateRecommendations(
    report: NpmAuditReport,
    vulnerabilities: VulnerabilityReport[]
  ): string[] {
    const recommendations: string[] = [];

    // Critical and high severity recommendations
    const critical = report.metadata.vulnerabilities.critical;
    const high = report.metadata.vulnerabilities.high;

    if (critical > 0) {
      recommendations.push(
        `üö® CRITICAL: Found ${critical} critical vulnerabilities. Address immediately!`
      );
    }

    if (high > 0) {
      recommendations.push(
        `‚ö†Ô∏è  HIGH: Found ${high} high-severity vulnerabilities. Prioritize fixing these.`
      );
    }

    // Check for direct dependencies
    const directVulns = vulnerabilities.filter((v) => v.isDirect);
    if (directVulns.length > 0) {
      recommendations.push(
        `üì¶ ${directVulns.length} vulnerabilities in direct dependencies. Update these packages first.`
      );
    }

    // Check for fixable vulnerabilities
    const fixableVulns = vulnerabilities.filter((v) => v.fixAvailable && !v.requiresBreakingChange);
    if (fixableVulns.length > 0) {
      recommendations.push(
        `‚úÖ ${fixableVulns.length} vulnerabilities can be fixed automatically with 'npm audit fix'`
      );
    }

    // Check for breaking changes
    const breakingVulns = vulnerabilities.filter((v) => v.requiresBreakingChange);
    if (breakingVulns.length > 0) {
      recommendations.push(
        `‚öôÔ∏è  ${breakingVulns.length} vulnerabilities require breaking changes. Review with 'npm audit fix --force'`
      );
    }

    // Snyk recommendation
    if (!this.config.snykEnabled) {
      recommendations.push(
        'üîç Consider enabling Snyk for advanced security scanning and monitoring'
      );
    }

    // General recommendations
    if (vulnerabilities.length === 0) {
      recommendations.push('‚ú® No vulnerabilities found! Your dependencies are secure.');
    } else {
      recommendations.push('üìö Review vulnerability details and plan remediation strategy');
      recommendations.push('üîÑ Regularly run security scans to catch new vulnerabilities');
    }

    return recommendations;
  }

  /**
   * Check if vulnerabilities are within acceptable thresholds
   */
  private checkThreshold(summary: Record<VulnerabilitySeverity | 'total', number>): boolean {
    const { maxVulnerabilities, failOnSeverity } = this.config;

    // Check count-based thresholds first (more specific)
    if (maxVulnerabilities) {
      if (
        maxVulnerabilities.critical !== undefined &&
        summary.critical > maxVulnerabilities.critical
      ) {
        return false;
      }

      if (
        maxVulnerabilities.high !== undefined &&
        summary.high > maxVulnerabilities.high
      ) {
        return false;
      }

      if (
        maxVulnerabilities.moderate !== undefined &&
        summary.moderate > maxVulnerabilities.moderate
      ) {
        return false;
      }

      if (
        maxVulnerabilities.low !== undefined &&
        summary.low > maxVulnerabilities.low
      ) {
        return false;
      }

      // If maxVulnerabilities is set, only use it and ignore failOnSeverity
      return true;
    }

    // Check severity-based failure (only if maxVulnerabilities not set)
    if (failOnSeverity && failOnSeverity.length > 0) {
      for (const severity of failOnSeverity) {
        if (summary[severity] > 0) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Save scan report to file
   */
  async saveReport(result: SecurityScanResult): Promise<string> {
    if (!this.config.saveReport || !this.config.outputDir) {
      return '';
    }

    // Ensure output directory exists
    await fs.mkdir(this.config.outputDir, { recursive: true });

    // Generate filename with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `security-scan-${timestamp}.json`;
    const filepath = path.join(this.config.outputDir, filename);

    // Save report
    await fs.writeFile(filepath, JSON.stringify(result, null, 2), 'utf-8');

    return filepath;
  }

  /**
   * Generate markdown report
   */
  generateMarkdownReport(result: SecurityScanResult): string {
    const lines: string[] = [];

    lines.push('# Security Vulnerability Scan Report\n');
    lines.push(`**Scan Date**: ${result.timestamp}\n`);
    lines.push(`**Status**: ${result.passesThreshold ? '‚úÖ PASSED' : '‚ùå FAILED'}\n`);

    // Summary
    lines.push('## Summary\n');
    lines.push('| Severity | Count |');
    lines.push('|----------|-------|');
    lines.push(`| Critical | ${result.summary.critical} |`);
    lines.push(`| High | ${result.summary.high} |`);
    lines.push(`| Moderate | ${result.summary.moderate} |`);
    lines.push(`| Low | ${result.summary.low} |`);
    lines.push(`| Info | ${result.summary.info} |`);
    lines.push(`| **Total** | **${result.summary.total}** |\n`);

    lines.push(`- **Fixable**: ${result.fixable}`);
    lines.push(`- **Requires Manual Review**: ${result.requiresManualReview}\n`);

    // Recommendations
    if (result.recommendations.length > 0) {
      lines.push('## Recommendations\n');
      result.recommendations.forEach((rec) => {
        lines.push(`- ${rec}`);
      });
      lines.push('');
    }

    // Vulnerabilities
    if (result.vulnerabilities.length > 0) {
      lines.push('## Vulnerabilities\n');

      result.vulnerabilities.forEach((vuln, index) => {
        lines.push(`### ${index + 1}. ${vuln.package}\n`);
        lines.push(`**Severity**: ${vuln.severity.toUpperCase()}`);
        lines.push(`**Title**: ${vuln.title}`);

        if (vuln.cvss) {
          lines.push(`**CVSS Score**: ${vuln.cvss}`);
        }

        if (vuln.cwe && vuln.cwe.length > 0) {
          lines.push(`**CWE**: ${vuln.cwe.join(', ')}`);
        }

        lines.push(`**Direct Dependency**: ${vuln.isDirect ? 'Yes' : 'No'}`);
        lines.push(`**Affected Versions**: ${vuln.affectedVersions}`);

        if (vuln.fixAvailable) {
          lines.push(`**Fix Available**: Yes${vuln.fixVersion ? ` (${vuln.fixVersion})` : ''}`);

          if (vuln.requiresBreakingChange) {
            lines.push('‚ö†Ô∏è  *Requires breaking change*');
          }
        } else {
          lines.push('**Fix Available**: No');
        }

        if (vuln.url) {
          lines.push(`**More Info**: ${vuln.url}`);
        }

        lines.push('');
      });
    }

    return lines.join('\n');
  }

  /**
   * Run complete security scan
   */
  async scan(): Promise<SecurityScanResult> {
    // Run npm audit
    const auditReport = await this.runNpmAudit();

    // Analyze results
    const result = this.analyzeAuditReport(auditReport);

    // Save report if configured
    if (this.config.saveReport) {
      await this.saveReport(result);

      // Also save markdown report
      const markdown = this.generateMarkdownReport(result);
      const markdownPath = path.join(
        this.config.outputDir!,
        'latest-security-report.md'
      );
      await fs.writeFile(markdownPath, markdown, 'utf-8');
    }

    // Run Snyk if enabled
    if (this.config.snykEnabled) {
      try {
        await this.runSnykTest();
      } catch (error) {
        console.warn('Snyk scan failed:', error);
      }
    }

    return result;
  }
}

/**
 * Quick scan function for convenience
 */
export async function runSecurityScan(config?: ScannerConfig): Promise<SecurityScanResult> {
  const scanner = new VulnerabilityScanner(config);
  return scanner.scan();
}

/**
 * Validate npm audit output format
 */
export function validateAuditReport(report: any): report is NpmAuditReport {
  if (report === null || report === undefined) {
    return false;
  }

  return (
    typeof report === 'object' &&
    'auditReportVersion' in report &&
    'vulnerabilities' in report &&
    'metadata' in report
  );
}
